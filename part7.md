Це дуже важливе питання. Python — мова інтерпретована, і в "сирому" вигляді вона може бути в 10-50 разів повільнішою за C++. Проте на олімпіадах для Python часто дають трохи більше часу (наприклад, 2-3 секунди замість 1), або ж можна використовувати **PyPy**.

Ось перелік технік ("трюків"), які допоможуть уникнути **TLE** (Time Limit Exceeded) та **MLE** (Memory Limit Exceeded).

---

### 1. Вибір інтерпретатора: PyPy3
Це найголовніша порада. Якщо тестувальна система (Eolymp, Codeforces, тощо) дозволяє вибрати **PyPy 3**, завжди обирай його.
*   **Чому:** PyPy використовує JIT-компіляцію. Цикли та арифметика працюють у 5-10 разів швидше.
*   **Нюанс:** PyPy споживає більше пам'яті, ніж CPython. Якщо обмеження пам'яті дуже жорстке (наприклад, 16-32 МБ), це може бути проблемою, але зазвичай дають 256 МБ+.

### 2. Швидке введення/виведення (Fast I/O)
Стандартний `input()` і `print()` дуже повільні. Якщо треба зчитати $10^5$ рядків, програма впаде по часу лише на вводі.

**Шаблон для старту:**
```python
import sys

# Переоприділяємо input на швидкий варіант
input = sys.stdin.readline

def solve():
    # Приклад зчитування:
    # n = int(input())
    # arr = list(map(int, input().split()))
    pass

if __name__ == "__main__":
    solve()
```

*   Для виведення великої кількості даних краще збирати все в один рядок або масив і робити один `print`, або використовувати `sys.stdout.write`.
    ```python
    # Погано (в циклі):
    # print(x)
    
    # Добре:
    results = []
    for x in ...:
        results.append(str(x))
    print('\n'.join(results)) # або ' '.join(...)
    ```

### 3. Локальні змінні швидші за глобальні
У Python доступ до локальних змінних (всередині функції) відбувається швидше, ніж до глобальних.
**Порада:** Завжди пиши код всередині функції `def main():` або `def solve():`, а не просто у тілі файлу.

```python
# Повільніше (глобальна область):
n = 1000000
for i in range(n): pass

# Швидше:
def main():
    n = 1000000
    for i in range(n): pass
main()
```

### 4. Оптимізація списків та масивів
*   **Pre-allocation:** Якщо знаєш розмір масиву, створи його одразу, а не роби `append` у циклі.
    ```python
    # Повільніше
    arr = []
    for _ in range(n):
        arr.append(0)

    # Швидше
    arr = [0] * n
    ```
*   **List Comprehensions:** Вони працюють трохи швидше за звичайні цикли `for` для створення списків.
    ```python
    arr = [i * 2 for i in range(n)] 
    ```

### 5. Рекурсія та її ліміти
Python має низький ліміт рекурсії (зазвичай 1000). Для DFS на графах чи деревах це призведе до `RecursionError`.

**Рішення:**
```python
import sys
sys.setrecursionlimit(200000) # Встановити із запасом > N
```
*Увага:* У CPython глибока рекурсія все одно повільна. У PyPy вона працює значно краще. Якщо рекурсія дуже глибока ($10^5$), краще переписати алгоритм на **ітеративний** (через стек `stack = []` і цикл `while`).

### 6. Мемоізація (кешування)
Для задач на Динамічне Програмування (ДП) через рекурсію використовуй декоратор `lru_cache`. Це автоматично зберігає результати функції.

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)
```
*Це замінює необхідність вручну створювати масив `memo`.*

### 7. Рядки
Рядки в Python незмінні (immutable).
*   **Ніколи не роби так у циклі:** `s += "a"` (це створює нову копію рядка на кожній ітерації, складність $O(N^2)$).
*   **Роби так:** Збирай символи в список і в кінці роби `''.join(list_of_chars)`.

### 8. Математичні хитрощі
*   **Ділення:** `//` (цілочисельне) швидше, ніж `int(a / b)`.
*   **Парність:** `x & 1` швидше за `x % 2`.
*   **Ступінь двійки:** `1 << n` краще за `2 ** n`.
*   **Бібліотеки:** Використовуй вбудовані функції `sum()`, `max()`, `min()`, оскільки вони написані на C і працюють дуже швидко. Але в межах *розумного* (не викликай `sum(arr)` всередині вкладеного циклу).

### 9. Пам'ять (Memory)
*   **Tuple vs List:** Кортежі `(1, 2)` займають менше пам'яті і працюють трохи швидше за списки `[1, 2]`.
*   **Генератори:** Якщо тобі треба пройтись по послідовності один раз (наприклад, для суми), не створюй список, використовуй генератор.
    ```python
    # Витрачає O(N) пам'яті
    s = sum([x*x for x in range(1000000)]) 

    # Витрачає O(1) пам'яті (генератор)
    s = sum(x*x for x in range(1000000))
    ```
*   **__slots__:** У G-задачах, якщо треба створити $10^6$ об'єктів власного класу, використовуй `__slots__`, щоб зекономити пам'ять.

### 10. Структури даних
*   **`in` для списку — повільно ($O(N)$).**
*   **`in` для множини/словника — миттєво ($O(1)$).**
    Якщо треба часто перевіряти наявність елемента, перетвори список на `set(arr)`.
*   **Черга:** Завжди використовуй `collections.deque` для черг. `list.pop(0)` працює за $O(N)$, а `deque.popleft()` — за $O(1)$.

### Чек-лист перед відправкою (якщо TLE):
1.  Чи використовую я `sys.stdin.readline`?
2.  Чи обрав я PyPy3?
3.  Чи немає конкатенації рядків у циклі?
4.  Чи немає зайвих перетворень типів всередині глибоких циклів?
5.  Чи не створюю я важкі об'єкти (списки, словники) всередині циклу, які можна винести назовні?
