

#### 1. Сортування за лінійний час (Сортування підрахунком / Counting Sort)
**Пояснення:** Ефективне, коли діапазон значень чисел малий (наприклад, до $10^6$). Ми не порівнюємо елементи, а рахуємо їх кількість. Складність $O(N + K)$, де $K$ — діапазон значень.

*   **Приклад 1: Класичний підрахунок**
    ```python
    arr = [4, 2, 2, 8, 3, 3, 1]
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for x in arr:
        count[x] += 1
        
    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.extend([i] * count[i]) # додаємо число i count[i] разів
    print(sorted_arr) # [1, 2, 2, 3, 3, 4, 8]
    ```
*   **Приклад 2: Сортування рядка (анаграма)**
    ```python
    s = "banana"
    cnt = [0] * 26 # для літер a-z
    for char in s:
        cnt[ord(char) - ord('a')] += 1
        
    res = ""
    for i in range(26):
        res += chr(ord('a') + i) * cnt[i]
    print(res) # "aaabnn"
    ```

#### 2. Швидкі алгоритми сортування (стандартні засоби)
**Пояснення:** Python використовує Timsort ($O(N \log N)$). На олімпіадах важливо вміти сортувати складні дані за допомогою ключа `key`.

*   **Приклад 1: Сортування за складною умовою (lambda)**
    ```python
    # Сортуємо слова: спочатку за довжиною (зростання), потім лексикографічно
    words = ["apple", "bat", "cat", "banana"]
    words.sort(key=lambda x: (len(x), x)) 
    print(words) # ['bat', 'cat', 'apple', 'banana']
    ```
*   **Приклад 2: Сортування списку кортежів**
    ```python
    points = [(1, 3), (2, 5), (1, 2)]
    # Сортуємо за x, якщо рівні - за y (стандартна поведінка)
    points.sort() 
    print(points) # [(1, 2), (1, 3), (2, 5)]
    ```

#### 3. Метод двох вказівників (Two Pointers)
**Пояснення:** Використовується для оптимізації перебору в **сортованих** масивах або для роботи з відрізками. Замість вкладених циклів ($O(N^2)$) отримуємо $O(N)$.

*   **Приклад 1: Сума двох чисел у сортованому масиві (2Sum)**
    ```python
    arr = [1, 3, 4, 6, 8, 10]; target = 10
    left, right = 0, len(arr) - 1
    while left < right:
        curr = arr[left] + arr[right]
        if curr == target:
            print(f"Found: {arr[left]} + {arr[right]}")
            break
        elif curr < target: left += 1
        else: right -= 1
    ```
*   **Приклад 2: Злиття двох відсортованих списків**
    ```python
    a = [1, 5, 9]; b = [2, 4, 8]
    res = []
    i = j = 0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            res.append(a[i]); i += 1
        else:
            res.append(b[j]); j += 1
    res.extend(a[i:]); res.extend(b[j:]) # додати залишки
    print(res) # [1, 2, 4, 5, 8, 9]
    ```

#### 4. Динамічне програмування (1D)
**Пояснення:** Розбиття задачі на підзадачі. Результат для `i` залежить від попередніх значень.

*   **Приклад 1: Числа Фібоначчі (знизу-вверх)**
    ```python
    n = 10
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    print(dp[n]) # 55
    ```
*   **Приклад 2: Задача про сходинки (можна ступати на 1 або 2 сходинки)**
    ```python
    # Скількома способами можна дістатися до n-ї сходинки?
    n = 5
    ways = [0] * (n + 1)
    ways[0] = 1; ways[1] = 1
    for i in range(2, n + 1):
        ways[i] = ways[i-1] + ways[i-2]
    print(ways[n]) # 8
    ```

#### 5. Жадібні алгоритми (Greedy)
**Пояснення:** На кожному кроці робимо локально найкращий вибір, сподіваючись на глобальний оптимум. Працює не завжди, але часто.

*   **Приклад 1: Задача про вибір заявок (Activity Selection)**
    ```python
    # (start, end). Вибрати максимум неперетинних подій.
    events = [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)]
    # Сортуємо за часом ЗАКІНЧЕННЯ!
    events.sort(key=lambda x: x[1]) 
    
    count = 0
    last_end = -1
    for start, end in events:
        if start >= last_end:
            count += 1
            last_end = end
    print(count) # 4: (1,3), (3,5), (5,7), (8,9)
    ```
*   **Приклад 2: Розмін монет (для стандартних номіналів)**
    ```python
    coins = [10, 5, 1]; amount = 28
    count = 0
    for coin in coins:
        count += amount // coin
        amount %= coin
    print(count) # 2x10 + 1x5 + 3x1 = 6 монет
    ```

#### 6. Часткові суми (Prefix Sums)
**Пояснення:** Дозволяє знаходити суму на відрізку `[L, R]` за `O(1)` після попередньої обробки за `O(N)`.
Формула: `Sum(L, R) = P[R] - P[L-1]`.

*   **Приклад 1: Швидка сума на відрізку**
    ```python
    arr = [1, 2, 3, 4, 5]
    n = len(arr)
    pref = [0] * (n + 1)
    for i in range(n):
        pref[i+1] = pref[i] + arr[i]
        
    # Сума з індексу 1 по 3 (числа 2, 3, 4) -> 9
    L, R = 1, 3 
    print(pref[R+1] - pref[L]) 
    ```
*   **Приклад 2: Різницевий масив (Difference Array)**
    *Задача: додати X до всіх чисел на відрізку `[L, R]` багато разів, а потім вивести масив.*
    ```python
    n = 5
    diff = [0] * (n + 2) # запас +1
    
    def update(l, r, val):
        diff[l] += val
        diff[r+1] -= val
        
    update(1, 3, 10) # додати 10 до елементів з 1 по 3
    
    curr = 0
    res = []
    for i in range(n):
        curr += diff[i]
        res.append(curr)
    print(res) # [0, 10, 10, 10, 0]
    ```

---
**Чи можу я продовжувати з Частиною 3 (Математика, Рекурсія, Бінарний пошук)?**
