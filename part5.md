
### ЧАСТИНА 5: Складна математика, Рядки, Інші алгоритми

#### 1. Бінарне піднесення у степінь (Binary Exponentiation)
**Пояснення:** Дозволяє обчислити $a^n$ (часто за модулем $m$) за час $O(\log n)$ замість $O(n)$.
Ідея: $a^{13} = a^8 \cdot a^4 \cdot a^1$ (використовуємо двійковий запис степеня).

*   **Приклад 1: Ітеративна реалізація (найпопулярніша)**
    ```python
    def binpow(a, n, m):
        res = 1
        a %= m
        while n > 0:
            if n % 2 == 1: # якщо біт встановлено
                res = (res * a) % m
            a = (a * a) % m
            n //= 2
        return res

    print(binpow(2, 10, 1000)) # 1024 % 1000 = 24
    ```
*   **Приклад 2: Вбудована функція Python**
    *Python має це "з коробки", але важливо знати алгоритм для матриць.*
    ```python
    # pow(base, exp, mod) працює за тим самим алгоритмом
    print(pow(2, 10, 1000)) # 24
    ```

#### 2. Розширений алгоритм Евкліда (Extended Euclid)
**Пояснення:** Знаходить такі коефіцієнти $x, y$, що $ax + by = \gcd(a, b)$. Використовується для знаходження оберненого елемента за модулем (Modular Inverse).

*   **Приклад 1: Знаходження x та y**
    ```python
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1 # gcd, x, y
        d, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return d, x, y

    g, x, y = extended_gcd(30, 12) # 30x + 12y = 6
    print(f"gcd={g}, x={x}, y={y}") # 6, 1, -2 -> 30*1 + 12*(-2) = 6
    ```
*   **Приклад 2: Обернений елемент за модулем**
    *Знайти $a^{-1} \pmod m$, тобто таке $x$, що $a \cdot x \equiv 1 \pmod m$.*
    ```python
    def mod_inverse(a, m):
        g, x, y = extended_gcd(a, m)
        if g != 1: raise Exception('Inverse does not exist')
        return (x % m + m) % m # щоб результат був додатнім

    print(mod_inverse(3, 11)) # 4 (бо 3*4 = 12 = 1 mod 11)
    ```

#### 3. Функція Ейлера (Euler's Totient Function)
**Пояснення:** $\phi(n)$ — кількість чисел від 1 до $n$, які взаємно прості з $n$.
Формула: $\phi(n) = n \cdot \prod (1 - \frac{1}{p})$, де $p$ — прості дільники.

*   **Приклад 1: Обчислення для одного числа**
    ```python
    def phi(n):
        result = n
        p = 2
        while p * p <= n:
            if n % p == 0:
                while n % p == 0:
                    n //= p
                result -= result // p
            p += 1
        if n > 1:
            result -= result // n
        return result

    print(phi(10)) # 4 (числа: 1, 3, 7, 9)
    ```
*   **Приклад 2: Мала теорема Ферма**
    *Якщо $p$ просте, то $a^{p-2} \equiv a^{-1} \pmod p$. Це швидкий спосіб знайти обернений елемент.*
    ```python
    MOD = 10**9 + 7
    a = 5
    inv_a = pow(a, MOD - 2, MOD) # 5^(-1) mod 10^9+7
    print((a * inv_a) % MOD) # 1
    ```

#### 4. Теорія ігор (Win/Loss Positions)
**Пояснення:** Ігри з повною інформацією (камінці, нім). Стан називається **програшним** (L), якщо з нього не можна зробити хід або всі ходи ведуть у виграшні для суперника. Стан **виграшний** (W), якщо існує хоча б один хід у програшний.

*   **Приклад 1: Гра з відніманням (1 або 2 камінці)**
    *Якщо $N \% 3 == 0$, це програш (L), інакше виграш (W).*
    ```python
    def can_win(n):
        return n % 3 != 0
    
    # 0 -> L (нема ходів)
    # 1 -> W (беремо 1 -> 0)
    # 2 -> W (беремо 2 -> 0)
    # 3 -> L (ходи в 2 або 1, які є W для ворога)
    ```
*   **Приклад 2: Рекурсія з мемоізацією (Generic Game)**
    ```python
    memo = {}
    def solve(state):
        if state == 0: return False # Lose
        if state in memo: return memo[state]
        
        # Можливі ходи: відняти 1, 3 або 4
        can_move_to_lose = False
        for move in [1, 3, 4]:
            if state >= move:
                if not solve(state - move): # Якщо опонент програє
                    can_move_to_lose = True
                    break
        
        memo[state] = can_move_to_lose
        return can_move_to_lose
    ```

#### 5. Матриці та рекурентність
**Пояснення:** Множення матриць дозволяє розв'язувати лінійні рекурентності (наприклад, $F_n = F_{n-1} + F_{n-2}$) за $O(\log n)$ шляхом піднесення матриці переходу в степінь.

*   **Приклад 1: Множення матриць 2x2**
    ```python
    def mat_mul(A, B, mod):
        C = [[0, 0], [0, 0]]
        for i in range(2):
            for j in range(2):
                for k in range(2):
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod
        return C
    ```
*   **Приклад 2: Фібоначчі за O(log n)**
    *Матриця переходу $M = [[1, 1], [1, 0]]$.*
    ```python
    # Використовує binpow, але з mat_mul замість множення чисел
    # M^n * [F1, F0] дає [Fn+1, Fn]
    ```

#### 6. Рядки: Префікс-функція (Prefix Function)
**Пояснення:** Масив $\pi$, де $\pi[i]$ — довжина найбільшого власного префікса рядка $S[0..i]$, який співпадає з його суфіксом. Використовується в алгоритмі Кнута-Морріса-Пратта (KMP).

*   **Приклад 1: Обчислення pi-функції**
    ```python
    s = "abacaba"
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i-1]
        while j > 0 and s[i] != s[j]:
            j = pi[j-1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    print(pi) # [0, 0, 1, 0, 1, 2, 3]
    ```
*   **Приклад 2: Пошук підрядка (KMP)**
    *Створюємо рядок "pattern#text" і рахуємо pi-функцію. Якщо $\pi[i] == len(pattern)$, ми знайшли входження.*

#### 7. Рядки: Z-функція
**Пояснення:** Масив $z$, де $z[i]$ — довжина найбільшого спільного префікса рядка $S$ і його суфікса, що починається з $S[i]$.

*   **Приклад 1: Ефективна реалізація O(N)**
    ```python
    s = "abacaba"
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    print(z) # [0, 0, 1, 0, 3, 0, 1] (z[0] не визначено або 0)
    ```

#### 8. Хеші та хешування (Hashing)
**Пояснення:** Поліноміальне хешування дозволяє порівнювати рядки за $O(1)$.
Формула: $H = (s[0]\cdot P^0 + s[1]\cdot P^1 + \dots) \pmod M$.

*   **Приклад 1: Обчислення хешу**
    ```python
    s = "olympiad"
    p = 31; m = 10**9 + 9
    hash_val = 0
    p_pow = 1
    for char in s:
        hash_val = (hash_val + (ord(char) - ord('a') + 1) * p_pow) % m
        p_pow = (p_pow * p) % m
    print(hash_val)
    ```
*   **Приклад 2: Порівняння підрядків (потрібні префіксні хеші)**
    ```python
    # Hash(L, R) = (H[R] - H[L-1]) * P^(-L) mod M
    # Або порівнювати: H(s1) * P^k == H(s2) * P^m
    ```

#### 9. Бітові операції та маски
**Пояснення:** Маска — це число, біти якого представляють стан (наприклад, підмножину множини).

*   **Приклад 1: Базові операції**
    ```python
    mask = 0
    # Встановити i-й біт (додати елемент i до множини)
    i = 2
    mask |= (1 << i) 
    
    # Перевірити i-й біт
    if mask & (1 << i):
        print("Bit is set")
        
    # Вимкнути i-й біт
    mask &= ~(1 << i)
    ```
*   **Приклад 2: Перебір усіх підмасок**
    *Ефективний спосіб перебрати всі підмножини множини `m`.*
    ```python
    m = 13 # 1101 (біти 0, 2, 3)
    s = m
    while s > 0:
        print(bin(s))
        s = (s - 1) & m
    print(bin(0))
    ```

---
**Чи можу я переходити до фінальної Частини 6 (Задачі рівня G - просунуті структури та графи)?**
